%!TEX root=main.tex
\chapter{Gilbert Typing}
\label{cha:gilberttyping}
\chapterquote{Experience without theory is blind, but theory without experience\\ is mere intellectual play.}{Immanuel Kant, (1724 - 1804)}

Program development in general is an error-prone and time-consuming task.
It usually involves besides the actual development phase several iterations of bug fixing.
In order to reduce the number of pitfalls a programmer can fall into, typing systems were developed.
Typing systems assign a \emph{type} to language constructs such as variables, functions and expressions.
That way the system gives meaning to an otherwise vacuous program.
In the memory of a computer, everything is represented as a sequence of bits, no matter whether it is an instruction code, memory address, character, boolean or floating-point number.
For the computer there is no way to intrinsically differentiate between the different meanings without an additional hint.
This hint comes in the form of types.
Knowing that a bit sequence represents a floating-point number, the computer is aware of the valid values and operations and can check for correct usage.

The pursued goal in typing theory is to develop a system which detects erroneous program behaviour and is at the same time \emph{sound} and \emph{complete}.
Soundness means that if a program passes the typer, then it behaves correctly.
Completeness means that if a program behaves correctly, then it will pass the typer.
However, it turned out that typing systems need to be extremely sophisticated in order to detect non-trivial errors and as a result they are often undecidable for non toy example languages.
For example, consider the division operation.
The code \code{1/0} would be well-typed by almost all common type checkers, because integers are divisable.
However, the code will cause a runtime error because of division by zero.
In order to detect this type of error, the type checking would have to be far more detailed.
Therefore, one usually relaxes the constraints.
In general, current type systems can already detect many different errors but they are still incomplete and only partially sound.

Type checking can be distinguished into two categories: \emph{static} and \emph{dynamic} type checking.
Static type checkers work on the source code and assign a type to each expression at compile-time.
If it detects any type incompatibilities, such as providing the wrong arguments to a function call, assigning conflicting data types or to apply not supported operations, the type checker will alert the programmer.
Most type checkers are designed to act conservative, meaning that they relax the constraints of soundness and completeness for the sake of decidability.
It is easy to see that we can reduce the typing problem to a halting problem, if we assume soundness and completeness.
For this purpose consider \cref{lst:typingHaltingProblem}.
In order to decide whether this code is well- or ill-typed, the typer has to decide whether \code{code\_which\_can\_run\_forever()} halts.
Since the halting problem is undecidable, also the set of programs producing a runtime type error is undecidable.
\begin{listing}[!h]
	\begin{CenteredBox}
		\begin{lstlisting}[language=C++]
if(code_which_can_run_forever()){
	code_with_type_error;
}else{
	code_without_type_error;
}
		\end{lstlisting}
	\end{CenteredBox}
	\caption{In order to type this code fragment, the typer has solve the halting problem.}
	\label{lst:typingHaltingProblem}
\end{listing}

In contrast to static typing, dynamic type checkers enrich each object with some kind of type tag which is used to check type compatibility at runtime.
However, possible errors are only recognised after the corresponding code has been executed.
A more thorough discussion about the advantages and disadvantages of both paradigms follows in \cref{sec:staticVSDynamic}.
In practice, there is hardly any static typing system which does not rely at least partially on dynamic typing as well.
Dynamic downcasts, for instance, as they are common in \code{C++}, can only be implemented by checking whether the underlying type is the target type or a subtype of it.

\section{Static Typing vs. Dynamic Typing}
\label{sec:staticVSDynamic}

Static type checking analyzes the program prior to execution to detect errors.
This has the advantage that possible programming mistakes are caught early in the development process.
An assignment of a string to a double would be an example for such a mistake.
As indicated by \cite{westland:jss2002a}, who investigated the influence of errors during software development and found out that unfixed errors become exponentially more costly with each phase, it is important to detect and correct errors as soon as possible.
Static typing usually requires the user to specify types explicitely in the source code, because the language lacks type inference or has ambiguities which prevent the type inference from inferring the correct type.
Java, for example, does not have type inference and therefore the user had specify types redundantly.
In line $1$ of \cref{lst:javaTypeAnnotation}, we see that we have to specify twice the type \code{Object}, even though this can easily be deduced from the right side of the assignment.
Furthermore, in line $4$ we see an addition of two integers.
It is clear that the result is again an integer and thus the \code{int} type specifier is dispensable.
\begin{listing}[!h]
	\begin{CenteredBox}
		\begin{lstlisting}[language=Java]
Object obj = new Object();
int a = 1;
int b = 0;
int c = a + b;			
		\end{lstlisting}
	\end{CenteredBox}
	\caption{Type annotations in Java.}
	\label{lst:javaTypeAnnotation}
\end{listing}

Proponents of static typing emphasize that explicit type information, as they occur in Java and many other programming languages, documents the code.
It is easier for a programmer to use existing code if he can identify function arguments and their types with one glance, for instance. 
Additionally, it is possible for the compiler to apply sophisticated optimization techniques if it knows the types.
The compiler could, for example, use more efficient machine instructions for floating-point calculation if it operates on these values.
Furthermore, it is possible to substitute virtual function calls for direct calls if the actual object type is known.
Another benefit of static typing is the increased type safety.
After passing the type check, the program is guaranteed to fulfill for all inputs some set of type safety properties.
This frees the runtime from checking them and thus the program can be executed more efficiently.
Type information additionally helps to provide a better programming experience in an IDE by offering type dependent context help.
If the IDE knows the type of a variable, then it can tell the prorgammer which methods this type supports, for instance.
And last but not least, explicit typing permits a better abstraction of functionality and thus modularity.
Interfaces can be defined to orchestrate the interaction between several software components allowing to develop them independently from each other.

In contrast to these arguments, advocates of dynamic typing argue that their approach is more vivid and better suited for prototyping, because the static typing approach is too rigid.
This comes especially into effect for programs in a highly dynamic environment with unknown or quickly changing requirements such as data integration.
Another advantage is that the compile time is reduced because of the fewer passes the compiler has to go through.
However, the avoided type checks have to be then realized within the runtime which adds overhead.
But the dynamic nature allows interpreters to dynamically load code more quickly, because all type checkings are deferred until its actual execution.
Moreover, dynamic languages support duck typing as a powerful tool to write reusable code.
The term duck typing originates from the poet James Whitcomb Riley, who stated: \enquote{When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.}~\cite{heim:2007a}.
Essentially, duck typing means that not the actual type of an object decides whether a program is well- or ill-typed but the set of supported methods and its properties.
For example, consider a function which calls a method \code{count} on its single parameter.
Then all function calls are valid which are called with an argument having a method \code{count} independent of its actual type.
That way, the programmer can write code which is applicable for a wide variety of types without having to specify them explicitely.
\textcite{ousterhout:c1998a} even goes further and claims that static typed languages does not guarantee a higher type safety than dynamic typed languages.
Furthermore, they are more verbose and it is difficult to write reusable code.
However, it is unclear in which way reducing language features leads to a more powerful and expressive language. 

The debate of whether statically or dynamically typed languages are superior has almost reached religious character.
It is likely that none of the approaches alone solves all problems.
Instead, a combination of the strengths of both paradigms promises the best results for the aforementioned problems~\cite{meijer:2004a}.

We are in the unfortunate situation that Matlab belongs to the class of dynamically typed languages and Gilbert requires type information for the parallel execution.
The reason why Gilbert needs type information is that the parallel data processing systems, used to run Gilbert distributedly, have to know which data types are passed from one worker node to another.
Therefore, we did not have any choice and had to enrich Matlab with type information.

There exists research of how to add explicit type information to Matlab.
For example, \textcite{hendren:2011a} introduced the special keyword \emph{atype} to Matlab which are understood and interpreted by an extended compiler.
The atype keyword basically acts as a type annotation and can be implemented within a special library or as a weaver.
Even though this approach seems quite promising, we decided to opt for a more transparent mechanism, namely type inference.
Type inference has the advantage that the Matlab user is not bothered by adding explicit type information and thus can continue writing his code in the usual fashion.
In the case that the type inference algorithm cannot properly infer the types, there has to be a way to resolve this problem.
We decided to pursue a similar approach as \textcite{furr:2009a}.
\citeauthor{furr:2009a} added type information to Ruby by adding special comments to the respective code sections.
Thereby, the code does not break with the Ruby standard and still contains type information.
As typing system, we use the Hindley-Milner (HM) type system~\cite{hindley:tams1969a,milner:jcss1978a} and a slightly derived form of algorithm W~\cite{damas:1982a} for type inference which will be described in the next section in detail.
Even though there exist more powerful type systems than the HM type system, it has the appealing charm that the algorithm W is sound, complete and decidable with respect to the type system.
Furhermore, it has proven to type several algorithms implemented within Gilbert correctly.

\section{Hindley-Milner Type Inference}

\section{Matrix Dimension Inference}