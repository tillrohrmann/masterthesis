%!TEX root=main.tex
\chapter{Implementation}
\label{cha:implementation}

\chapterquote{In any moment of decision, the best thing you can do is the right thing, the next best thing is the wrong thing, and the worst thing you can do is nothing.}{Theodore Roosevelt, (1858 - 1919)}

The development of Gilbert involved the implementation of the complete technology stack of a programming language.
For each technology, we had to decide how to implement it.
The lexer and parser, for example, can be automatically generated using tools such as ANTLR~\cite{antlr}, Bison~\cite{bison} or Yacc~\cite{yacc}.
However, using these tools would have required to manage the complexity of several frameworks and probably a lot of boilerplate code to fuse them together.
Therefore, we looked for a tool with the potential to implement the complete stack of Gilbert.

Fortunately, the Scala language~\cite{scala,odersky:2010a} unifies all required technologies under one umbrella.
Scala is a highly scalable language, well suited for script sized programs as well as enterprise applications.
The language combines object oriented and functional programming, giving a maximum of flexibility to the programmer.
The Scala code is compiled to Java bytecode and thus executed on a JVM.
This makes the language platform independent to the greatest possible extent.
Furthermore, it can integrate exisiting Java code and thus benefit from the rich set of Java libraries.
And last but not least, it is like the new cool kid on the block of programming languages, which everyone likes.

An important aspect of our choice was how easily a parser and a compiler can be implemented with Scala.
If one decides to implement these programs within a popular language such as Java, C/C++ or C\# and without any additional tools, then it quickly becomes a tedious and error-prone task.
That's the reason why tools like Yacc and ANTLR have emerged.
Scala circumvents this problem by providing an internal domain specific language (DSL) for an easy and quick development of parsers and lexers.
This DSL is also known as Scala Parser Combinators.
Once an abstract syntax tree has been generated using these parser combinators, it is very easy to develop a compiler using Scala's pattern matching functionality.
The pattern matching capabilities of Scala are similar to functional languages, such as Haskell, ML or OCaml.
It can even be applied on object hierarchies, making it a powerful tool for OOP and functional programming likewise.
The Scala Parser Combinators generate recursive descent parsers which are capable of parsing LL(*) grammars.

\section{Math-Backend}

In \cref{cha:gilbertruntime} we have explained the representation of distributed matrices and how the intermediate operators are mapped to dataflow plans.
What was left out, though, is how the local operations on the block-level are implemented.
Consider, for example, the matrix multiplication of two distributed matrices.
The result is obtained by joining the blocks of both operands, performing a local matrix multiplication on a matching block pair and reducing the intermediate results.
The local matrix multiplication is self-contained and has to be executed by some algorithm.
Since there already exist highly optimized algorithms for different matrix representations, dense or sparse, we do not have to reinvent the wheel.

One of the numerous linear algebra libraries for the Java ecosystem is Mahout~\cite{mahout:2011a}.
The math library of Mahout is mainly written in Java and thus offers a Java binding.
Initially, Mahout was used to implement the local linear algebra operations of Gilbert.
However, it quickly turned out that Mahout lacked reliable support for sparse matrices.
Since Gilbert is geared towards being a linear algebra environment for sparse matrices, we had to look for a different library.
Next we came across Breeze~\cite{breeze}, a library for numerical processing written in Scala.
The fact that it offers a Scala binding allowed it to integrate seamlessly into Gilbert.
We have chosen this library as our math backend because it is clean, more reliable than Mahout and extremely powerful.

Breeze offers data structures for all linear algebra primitives, such as matrices and vectors.
Additionally, it supports sparse and dense variants of them.
For each version, Breeze is shipped with elaborate algorithms implementing the linear algebra operations.
In case that the host has a BLAS or LAPACK library installed, which is compiled and optimized for the underlying architecture, Breeze automatically detects and uses them.
That way, Breeze can achieve near optimal results when multiplying dense matrices compared to compiled languages such as C/C++ and Fortran.

\section{Execution Engines}

\subsection{Stratosphere}

\subsection{Spark}

\begin{itemize}
	\item Implemented in Scala
	\item Parser combinators used for parser
	\item Encountered problems
	\begin{itemize}
		\item Distinguish string literals from transpose operation
		\item Implement cell arrays, which have to be constructed while typing the program
	\end{itemize}
	\item Math backend
	\begin{itemize}
		\item Breeze
		\item Mahout
	\end{itemize}
	\item Stratosphere related problems
	\begin{itemize}
		\item Fix of compilation logic to support reuse of expressions
		\item Explicit representation of boolean matrix because the framework does not support implicits which are necessary to realize a generic matrix
	\end{itemize}
\end{itemize}

