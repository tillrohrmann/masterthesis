%!TEX root=main.tex
\chapter{Architecture}
\label{cha:architecture}

\chapterquote{We shape our buildings; thereafter they shape us.}{Winston Churchill, (1874 - 1965)}

Gilbert provides a Matlab-like language for distributed sparse linear algebra operations.
As such a system, it comprises the complete stack of functionalities necessary to implement a programming language.
At first, the system has to divide the given source code into tokens.
These tokens are parsed and an abstract syntax tree (AST) is generated from them.
This formal representation of the program is well suited for further transformations.
In order to generate an execution plan for one of the supported execution engines, we first have to assign types to the occurring expressions.
This is done by the typing system.
Afterwards, the compiler generates the actual plan which can then be executed in parallel.

Since we had to implement the whole stack of functionalities of a programming language, Gilbert became quite complex.
In order to control this complexity, Gilbert's functionalities were separated into different layers with distinct tasks.
The layered system architecture is shown in \cref{fig:systemArchitecture}.
The separation of concerns limits the complexity of each layer so that each one of them becomes manageable.
In cooperation, though, they implement a highly elaborate system.

\begin{figure}
	\centering
	\includegraphics[width=0.5\linewidth]{images/systemArchitecture.png}
	\caption{The layered system architecture of Gilbert. The language layer is responsible for parsing, typing and compiling the given Matlab code. The intermediate layer facilitates high-level optimization strategies. The runtime layer is responsible for executing the specified program in parallel.}
	\label{fig:systemArchitecture}
\end{figure}

The first layer is the language layer.
It contains all functionality to parse the given Matlab code and to compile it into the intermediate representation.
The second layer is the intermediate layer.
This layer receives the intermediate form of the Matlab code and translates it into an execution plan for the runtime layer.
The resulting plan depends on the actually used execution engine.
Even though, the intermediate layer only contains the execution plan generator, it is intended to also host the optimizer.
The intermediate format is the ideal representation to apply language independent high-level transformations.
Once the program has been translated into an execution engine's specific plan, it is executed on the respective back end.
In the following sections, we will further describe the individual layers.

\section{Language Layer}

The language layer contains all the logic for processing Matlab source code into the intermediate representation, see \cref{cha:intermediaterepresentation} for more details.
The layer itself is subdivided into three layers.
The first of these sublayers is the lexer and parser of Matlab code.
Gilbert uses a recursive descent parser with backtracking which is capable of parsing any LL(*) grammar.
Consequently, it can also parse Gilbert's front end language as specified in \cref{sec:languageGrammar}.

Once the Matlab code is parsed, it is given to the next layer, namely the typing layer.
Here, the produced AST is attributed with type information.
This information is inferred automatically from the source code without any need for explicit type annotations.
The typer makes use of the Hindley-Milner type inference system, as it is described in \cref{sec:hmInference}.
After the types have been inferred, a new AST with additional type information is generated.

The type information enriched AST is given to the last sublayer.
The compiler is responsible for translating the AST into a front end independent representation of linear algebra operations.
In \cref{cha:intermediaterepresentation} we describe the format Gilbert uses to represent linear algebra operations in a generalized format.
In fact, it is also some form of AST just without the peculiarities of Matlab.

\section{Intermediate Layer}

The intermediate layer contains the optimizer and the execution plan generator.
The optimizer works on the intermediate representation of the Gilbert program.
It applies the optimziation described in \cref{cha:optimizer}.
The execution plan generator's task is to translate the intermediate format into the execution engine's specific format.
Currently, the system supports local execution and two engines for distributed execution, namely Stratosphere and Spark.

For the local execution, Gilbert employs an interpreter.
The interpreter directly executes the intermediate representation.
Beginning at the root of the dependency tree, the interpreter utilizes a recursive-descent strategy to evaluate each node.
In order to evaluate a given node of the tree, the interpreter first descends to its children.
After having retrieved the results of the children nodes, the parent node is evaluated.

The distributed execution engines do not support immediate execution of the individual nodes.
Instead, the plan generator has to create an execution plan for Stratosphere and Spark, which is lazily executed upon submission.
Fortunately, Stratosphere and Spark offer a similar programming API which only differs slightly.
Thus, Gilbert can translate the distinct linear algebra operations using the same general building blocks as described in \cref{sec:LinearAlgebraOperations}.
The execution plan is generated using a recursive-descent approach similar to the local interpreter.
Once the intermediate representation has been transformed, the plan is sent to the respective system which triggers the parallel execution.

\section{Runtime Layer}

The runtime layer marks the transition from Gilbert to one of the supported execution engines.
It is more of a conceptual abstraction than actual work happens here.
Even though, Gilbert only supports 3 different engines at the moment, it should be easy to add support for further execution systems.
